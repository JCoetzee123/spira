import spira
import numpy as np
from spira import param, shapes
from spira.lpe import mask
from demo.pdks import ply
from spira.lpe.containers import __CellContainer__, __NetContainer__, __CircuitContainer__
from spira.lne.net import Net
from copy import copy, deepcopy
from spira.lpe.mask_layers import Metal
from spira.lpe.devices import Device, DeviceLayout
from spira.lpe.devices import Gate
from spira.lpe.pcells import __PolygonOperator__

from spira.lgm.route.manhattan_base import RouteManhattan
from spira.lgm.route.basic import RouteShape, RouteBasic, Route
from spira.lpe.pcells import  __NetlistCell__
from spira.lpe.boxes import BoundingBox


RDD = spira.get_rule_deck()


class Circuit(__CircuitContainer__):
    """ Deconstructs the different hierarchies in the cell. """

    lcar = param.IntegerField(default=0.1)
    algorithm = param.IntegerField(default=6)
    level = param.IntegerField(default=1)

    mask = param.DataField(fdef_name='create_mask')

    def create_mask(self):
        cell = None
        if self.level == 2:
            cell = LayoutConstructor(cell=self)
        elif self.level == 3:
            pass
        elif self.level == 4:
            pass
        return cell

    def create_devices(self, elems):
        # FIXME: Assumes level 1 hierarchical cell.
        if self.cell is None:
            for S in self.elementals.sref:
                if issubclass(type(S.ref), Device):
                    elems += S
        else:
            c2dmap = {}
            deps = self.cell.dependencies()
            for key in RDD.DEVICES.keys:
                DeviceTCell = deepcopy(RDD.DEVICES[key].PCELL)
                DeviceTCell.center = (0,0)
                for C in deps:
                    if 'jj' in C.name:
                        L = DeviceLayout(name=C.name, cell=C, level=1)
                        D = DeviceTCell(metals=L.metals, contacts=L.contacts)
                        c2dmap.update({C: D})
                    elif 'via' in C.name:
                        L = DeviceLayout(name=C.name, cell=C, level=1)
                        D = DeviceTCell(metals=L.metals, contacts=L.contacts)
                        c2dmap.update({C: D})
            for c in self.cell.dependencies():
                self.__cell_swapper__(elems, c, c2dmap)
        return elems

    def create_boxes(self, boxes):
        """ Generate bounding boxes around each Device. """
        # FIXME: Assumes level 1 hierarchical cell.
        for S in self.devices:
            boxes += BoundingBox(
                cell=S.ref,
                midpoint=S.midpoint,
                rotation=S.rotation,
                reflection=S.reflection,
                magnification=S.magnification
            )
        return boxes

    def create_routes(self, routes):
        if self.cell is not None:
            elems = spira.ElementList()
            for e in self.cell.elementals:
                if issubclass(type(e), spira.Polygons):
                    elems += e
            R = RouteManhattan(elementals=elems)
            routes += spira.SRef(R)
        return routes

    def create_ports(self, ports):
        if self.cell is not None:
            flat_elems = self.cell.flat_copy()
            port_elems = flat_elems.get_polygons(layer=RDD.PURPOSE.TERM)
            label_elems = flat_elems.labels
            for port in port_elems:
                for label in label_elems:
                    lbls = label.text.split(' ')
                    s_p1, s_p2 = lbls[1], lbls[2]
                    p1, p2 = None, None
                    for m1 in RDD.PLAYER.get_physical_layers(purposes=['METAL', 'GND']):
                        if m1.layer.name == s_p1:
                            p1 = spira.Layer(name=lbls[0],
                                number=m1.layer.number,
                                datatype=RDD.GDSII.TEXT
                            )
                        if m1.layer.name == s_p2:
                            p2 = spira.Layer(name=lbls[0],
                                number=m1.layer.number,
                                datatype=RDD.GDSII.TEXT
                            )
                    if p1 and p2 :
                        if label.point_inside(ply=port.polygons[0]):
                            ports += spira.Term(
                                name=label.text,
                                layer1=p1, layer2=p2,
                                midpoint=label.position
                            )
        return ports

    def create_netlist(self):
        self.mask.netlist


class LayoutConstructor(__NetlistCell__):
    """ Constructs a single cell from the hierarchical 
    levels generated by the Circuit class. """

    def create_elementals(self, elems):
        elems += spira.SRef(Gate(cell=self.cell))
        # for e in self.cell.devices:
            # elems += e
        return elems

    def create_nets(self, nets):
        for s in self.elementals.sref:
            g = s.ref.netlist
            if g is not None:
                for n in g.nodes():
                    p = np.array(g.node[n]['pos'])
                    m = np.array(s.midpoint)
                    g.node[n]['pos'] = p + m
                nets += g
        return nets

    def create_netlist(self):
        self.g = self.merge

        # self.g = self.nodes_combine(algorithm='d2s')
        # self.g = self.nodes_combine(algorithm='d2d')
        # self.g = self.nodes_combine(algorithm='s2s')

        self.plot_netlist(G=self.g, graphname=self.name, labeltext='id')

