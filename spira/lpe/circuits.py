import spira
import time
import numpy as np
from spira import param, shapes
from spira.lpe import mask
from demo.pdks import ply
from spira.lpe.containers import __CellContainer__, __NetContainer__, __CircuitContainer__
from spira.lne.net import Net
from copy import copy, deepcopy
from spira.lpe.mask_layers import Metal
from spira.lpe.devices import Device, DeviceLayout
from spira.lpe.devices import Gate
from spira.lpe.pcells import __PolygonOperator__

from spira.lgm.route.manhattan_base import Route
from spira.lgm.route.basic import RouteShape, RouteBasic
from spira.lpe.pcells import  __NetlistCell__
from spira.lpe.boxes import BoundingBox
from halo import Halo


RDD = spira.get_rule_deck()


class Circuit(__CircuitContainer__):
    """ Deconstructs the different hierarchies in the cell. """

    lcar = param.IntegerField(default=0.1)
    algorithm = param.IntegerField(default=6)
    level = param.IntegerField(default=1)

    mask = param.DataField(fdef_name='create_mask')

    def create_mask(self):
        gate_cell = LayoutConstructor(cell=self.cell)
        return gate_cell

    def create_elementals(self, elems):
        elems = super().create_elementals(elems)
        elems += spira.SRef(self.mask)
        return elems

    def create_netlist(self):

        spinner = Halo(text='Extracting netlist', spinner='dots')
        spinner.start()

        self.mask.netlist

        spinner.succeed('Netlist extracted.')
        spinner.stop()


class LayoutConstructor(__NetlistCell__):
    """ Constructs a single cell from the hierarchical 
    levels generated by the Circuit class. """

    def create_elementals(self, elems):

        print('[*] Connecting GATE with devices')

        start = time.time()

        gate = Gate(cell=self.cell)
        elems += spira.SRef(gate)

        end = time.time()
        print('Gate calculation time {}:'.format(end - start))
        
        start = time.time()

        for b in self.cell.boxes:
            elems += spira.SRef(b)
            
        end = time.time()
        print('BOX calculation time {}:'.format(end - start))

        # for e in self.cell.devices:
        #     elems += e
        return elems

    def create_nets(self, nets):
        # for i, s in enumerate(self.elementals.sref):
        for i, s in enumerate(self.cell.devices):

            if issubclass(type(s.ref), Device):
                g = s.ref.netlist
                if g is not None:
                    for n in g.nodes():
                        if 'device' in g.node[n]:
                            g.node[n]['device'].node_id = '{}_{}_{}'.format(
                                s.ref.name,
                                g.node[n]['device'].node_id,
                                i
                            )
                        else:
                            g.node[n]['surface'].node_id = '{}_{}_{}'.format(
                                s.ref.name,
                                g.node[n]['surface'].node_id,
                                i
                            )
                            g.node[n]['device'] = g.node[n]['surface']

        for i, s in enumerate(self.elementals.sref):
            g = s.ref.netlist
            if g is not None:
                for n in g.nodes():
                    p = np.array(g.node[n]['pos'])
                    m = np.array(s.midpoint)
                    g.node[n]['pos'] = p + m
                nets += g
        return nets

    def create_netlist(self):

        self.g = self.merge

        # self.g = self.nodes_combine(algorithm='d2s')
        # self.g = self.nodes_combine(algorithm='d2d')
        # self.g = self.nodes_combine(algorithm='s2s')

        self.plot_netlist(G=self.g, graphname=self.name, labeltext='id')

    def create_ports(self, ports):
        
        print('[*] Calculate Layout ports')

        start = time.time()

        for D in self.cell.devices:
            for name, port in D.ports.items():
                if port.locked is False:
                    edgelayer = deepcopy(port.gdslayer)
                    edgelayer.datatype = 100
                    m_term = spira.Term(
                        name=port.name,
                        gdslayer=deepcopy(port.gdslayer),
                        midpoint=deepcopy(port.midpoint),
                        orientation=deepcopy(port.orientation),
                        reflection=port.reflection,
                        edgelayer=edgelayer,
                        width=port.width,
                    )
                    ports += m_term

        for R in self.cell.routes:
            for name, port in R.ports.items():
                if port.locked is False:
                    edgelayer = deepcopy(port.gdslayer)
                    edgelayer.datatype = 101
                    m_term = spira.Term(
                        name=port.name,
                        gdslayer=deepcopy(port.gdslayer),
                        midpoint=deepcopy(port.midpoint),
                        orientation=deepcopy(port.orientation),
                        reflection=port.reflection,
                        edgelayer=edgelayer,
                        width=port.width,
                    )
                    ports += m_term


        # gate = Gate(cell=self.cell)

        # for pl in RDD.PLAYER.get_physical_layers(purposes='METAL'):
        #     for m in gate.get_metal_polygons_for_ports(pl):
        #         for p in m.ports:
        #             for t in self.cell.terminals:
        #                 edgelayer = deepcopy(p.gdslayer)
        #                 edgelayer.datatype = 82
        #                 arrowlayer = deepcopy(p.gdslayer)
        #                 arrowlayer.datatype = 83
        #                 if p.encloses_midpoint(polygon=t.edge.polygons):
        #                     ports += spira.Term(
        #                         name=t.name,
        #                         midpoint=p.midpoint,
        #                         orientation=p.orientation,
        #                         edgelayer=edgelayer,
        #                         arrowlayer=arrowlayer,
        #                         width=p.width,
        #                         length=p.length

        #                     )
                            
        end = time.time()
        print('Layout port calculation time {}:'.format(end - start))

        return ports
